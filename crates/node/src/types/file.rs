use crate::types::transaction;
use crate::types::Hash;
use eyre::Result;
use serde::Deserialize;
use serde::Serialize;
use std::path::Path;
use std::path::PathBuf;

pub async fn open_task_file(
    data_dir: &PathBuf,
    task_id: &str,
    path: &str,
) -> Result<tokio::io::BufReader<tokio::fs::File>> {
    let mut path = Path::new(path);
    if path.is_absolute() {
        path = path.strip_prefix("/")?;
    }
    let path = PathBuf::new().join(data_dir).join(task_id).join(path);
    let fd = tokio::fs::File::open(path).await?;
    Ok(tokio::io::BufReader::new(fd))
}

//describe file data that is stored in the database.
// to manipulate file on disk use the equivalent type state definition File<T>
#[derive(Clone, Debug, Default, PartialEq, Deserialize, Serialize, sqlx::FromRow)]
pub struct DbFile {
    pub name: String,
    pub url: String,
    pub checksum: Hash,
}

impl DbFile {
    pub fn try_from_prg_data(
        value: &transaction::ProgramData,
    ) -> Result<Option<Self>, &'static str> {
        let file = match value {
            transaction::ProgramData::Input {
                file_name,
                file_url,
                checksum,
            } => Some(DbFile {
                name: file_name.clone(),
                url: file_url.clone(),
                checksum: checksum.clone().into(),
            }),
            transaction::ProgramData::Output {
                source_program: _,
                file_name: _,
            } => {
                //Output file are not use by Tx management.
                None
            }
        };

        Ok(file)
    }
}

// Type state definition of a file to manage all the different case of file manipulation.
// Download: Use to download the file data and move them to the right place. Constructed using the other type.
// ProofVerif: A file attached to a proof or verify Tx: Only downloaded on distant host. Nothing done on the host when the Tx has been executed.
// Vm(Hash): File generated by the VM execution. Move from Vm to ProofVerif place.
// Image: File attached to a Deploy Tx. Identify an image that are stored in the image directory.
#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct File<E> {
    pub name: String,
    pub url: String,
    pub checksum: Hash,
    pub extention: E,
}

impl<E> File<E> {
    pub fn build(name: String, url: String, checksum: Hash, extention: E) -> Self {
        File {
            name,
            url,
            checksum,
            extention,
        }
    }
}

//File type
#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct Download(String);
//Asset file use download and install the file data locally.
impl File<Download> {
    pub fn new(name: String, url: String, checksum: Hash, tx_hash: Hash) -> Self {
        File::build(name, url, checksum, Download(tx_hash.to_string()))
    }

    pub fn get_relatif_path(&self) -> PathBuf {
        let file_name = Path::new(&self.name).file_name().unwrap();
        let mut path = PathBuf::from(&self.extention.0);
        path.push(file_name);
        path
    }
}

#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct ProofVerif;
impl File<ProofVerif> {
    pub fn new(path: String, http_download_host: String, checksum: Hash) -> Self {
        let uuid = uuid::Uuid::new_v4();
        //format file_name to keep the current filename and the uuid.
        //put uuid at the end so that the uuid is use to save the file.
        let new_file_name = format!("{}/{}", path, uuid);

        File::build(new_file_name, http_download_host, checksum, ProofVerif)
    }

    pub fn into_download_file(self, tx_hash: Hash) -> File<Download> {
        //get uuid from file name
        let uuid = Path::new(&self.name).file_name().unwrap();
        File::<Download>::new(
            self.name.to_string(),
            format!("{}/{}/{}", self.url, tx_hash, uuid.to_str().unwrap()),
            self.checksum.to_string().into(),
            tx_hash,
        )
    }

    pub fn get_relatif_path(&self, tx_hash: Hash) -> PathBuf {
        //get uuid from file name
        let uuid = Path::new(&self.name).file_name().unwrap();
        let mut path = PathBuf::from(tx_hash.to_string());
        path.push(uuid);
        path
    }

    pub fn vec_to_bytes(vec: &[File<ProofVerif>]) -> Result<Vec<u8>, bincode::Error> {
        bincode::serialize(vec)
    }
}

impl From<DbFile> for File<ProofVerif> {
    fn from(file: DbFile) -> Self {
        File::<ProofVerif>::new(file.name, file.url, file.checksum)
    }
}

// Describe a file generated by the VM.
#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct Vm(Hash);
impl File<Vm> {
    pub fn new(path: String, checksum: Hash, task_tx: Hash) -> Self {
        File::build(path, String::new(), checksum, Vm(task_tx))
    }

    pub fn get_relatif_path(&self) -> PathBuf {
        let mut file_path = Path::new(&self.name);
        if file_path.is_absolute() {
            file_path = file_path.strip_prefix("/").unwrap(); // Unwrap tested in `is_absolute()`.
        }

        let mut path = PathBuf::from(self.extention.0.to_string());
        path.push(file_path);
        path
    }
}

pub async fn move_vmfile(
    source: &File<Vm>,
    dest: &File<ProofVerif>,
    base_path: &Path,
    proofverif_tx_hash: Hash,
) -> Result<()> {
    let src_file_path = base_path.to_path_buf().join(source.get_relatif_path());
    let dst_file_path = base_path
        .to_path_buf()
        .join(dest.get_relatif_path(proofverif_tx_hash));

    tracing::debug!(
        "moving file from {:#?} to {:#?}",
        src_file_path,
        dst_file_path
    );

    // Ensure any necessary subdirectories exists.
    if let Some(parent) = dst_file_path.parent() {
        tokio::fs::create_dir_all(parent)
            .await
            .expect("task file mkdir");
    }

    tokio::fs::rename(src_file_path, dst_file_path)
        .await
        .map_err(|e| e.into())
}

#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct Image(Hash);
impl File<Image> {
    pub fn try_from_prg_meta_data(value: &transaction::ProgramMetadata) -> Self {
        File::build(
            value.name.clone(),
            value.image_file_url.clone(),
            value.image_file_checksum.clone().into(),
            Image(value.hash),
        )
    }
}

impl From<File<Image>> for File<Download> {
    fn from(file: File<Image>) -> Self {
        //image file has the image directory happened at the beginning.
        let mut extention = PathBuf::from("images");
        extention.push(file.extention.0.to_string());
        File::build(
            file.name,
            file.url,
            file.checksum,
            Download(extention.to_str().unwrap().to_string()),
        )
    }
}
