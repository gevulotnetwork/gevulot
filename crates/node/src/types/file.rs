use crate::types::transaction;
use crate::types::Hash;
use eyre::Result;
use serde::Deserialize;
use serde::Serialize;
use std::path::Path;
use std::path::PathBuf;

pub async fn open_task_file(
    data_dir: &PathBuf,
    path: &str,
) -> Result<tokio::io::BufReader<tokio::fs::File>> {
    let mut path = Path::new(path);
    if path.is_absolute() {
        path = path.strip_prefix("/")?;
    }
    let path = PathBuf::new().join(data_dir).join(path);
    let fd = tokio::fs::File::open(path).await?;
    Ok(tokio::io::BufReader::new(fd))
}

// Describe a file use by an executed task.
#[derive(Clone, Debug)]
pub struct TaskVMFile {
    pub file_path: String,
}

impl TaskVMFile {
    pub fn try_from_prg_data(
        tx_hash: Hash,
        parent_output_files: &[File<ProofVerif>],
        value: &transaction::ProgramData,
    ) -> Result<TaskVMFile, String> {
        match value {
            transaction::ProgramData::Input { file_name, .. } => {
                let mut file_path = Path::new(file_name);
                if file_path.is_absolute() {
                    file_path = file_path.strip_prefix("/").unwrap(); // Unwrap tested in `is_absolute()`.
                }

                let file_path = PathBuf::new()
                    .join(tx_hash.to_string())
                    .join(file_path)
                    .to_str()
                    .unwrap()
                    .to_string();

                Ok(TaskVMFile { file_path })
            }
            transaction::ProgramData::Output {
                source_program: _,
                file_name,
            } => {
                //get the file path from the parent tx file list.
                match parent_output_files
                    .iter()
                    .find(|file| &file.name == file_name)
                {
                    Some(file) => {
                        let file_path =
                            file.get_relatif_path(tx_hash).to_str().unwrap().to_string();
                        Ok(TaskVMFile { file_path })
                    }
                    None => Err(format!(
                        "Tx:{} program output file:{file_name} not found",
                        tx_hash,
                    )),
                }
            }
        }
    }
}

//describe file data that is stored in the database.
// to manipulate file on disk use the equivalent type state definition File<T>
#[derive(Clone, Debug, Default, PartialEq, Deserialize, Serialize, sqlx::FromRow)]
pub struct DbFile {
    pub name: String,
    pub url: String,
    pub checksum: Hash,
}

// Type state definition of a file to manage all the different case of file manipulation.
// Download: Use to download the file data and move them to the right place. Constructed using the other type.
// ProofVerif: A file attached to a proof or verify Tx: Only downloaded on distant host. Nothing done on the host when the Tx has been executed.
// Vm(Hash): File generated by the VM execution. Move from Vm to ProofVerif place.
// Image: File attached to a Deploy Tx. Identify an image that are stored in the image directory.
#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct File<E> {
    pub name: String,
    pub url: String,
    pub checksum: Hash,
    pub extention: E,
}

impl<E> File<E> {
    pub fn build(name: String, url: String, checksum: Hash, extention: E) -> Self {
        File {
            name,
            url,
            checksum,
            extention,
        }
    }
}

//File type
#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct Download((String, bool));
// Asset file use download and install the file data locally.
// verify_exist: define if the exist verification do a real file system verification.
// Only file path using checksum should do file exist verification.
impl File<Download> {
    pub fn new(
        name: String,
        url: String,
        checksum: Hash,
        tx_hash: Hash,
        verify_exist: bool,
    ) -> Self {
        File::build(
            name,
            url,
            checksum,
            Download((tx_hash.to_string(), verify_exist)),
        )
    }

    // Save Relative File path for downloaded files is <Tx Hash>/<self.name>
    pub fn get_save_path(&self) -> PathBuf {
        let file_name = Path::new(&self.name)
            .file_name()
            .unwrap_or(std::ffi::OsStr::new(""));
        let mut path = PathBuf::from(&self.extention.0 .0);
        path.push(file_name);
        path
    }

    pub async fn exist(&self, root_path: &Path) -> bool {
        if self.extention.0 .1 {
            let file_path = root_path.join(self.get_save_path());
            tokio::fs::try_exists(file_path).await.unwrap_or(false)
        } else {
            false
        }
    }
}

#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct ProofVerif;
impl File<ProofVerif> {
    pub fn new(path: String, http_download_host: String, checksum: Hash) -> Self {
        File::build(path, http_download_host, checksum, ProofVerif)
    }

    pub fn into_download_file(self, tx_hash: Hash) -> File<Download> {
        let relative_path = self.get_relatif_path(tx_hash).to_str().unwrap().to_string();
        let url = format!("{}/{}", self.url, relative_path);
        File::<Download>::new(relative_path, url, self.checksum, tx_hash, true)
    }

    // Save Relative File path for ProofVerif files is <Tx Hash>/<self.checksum>/<filename>
    pub fn get_relatif_path(&self, tx_hash: Hash) -> PathBuf {
        let file_name = Path::new(&self.name).file_name().unwrap_or_default();
        let mut path = PathBuf::from(tx_hash.to_string());
        path.push(self.checksum.to_string());
        path.push(file_name);
        path
    }

    pub fn vec_to_bytes(vec: &[File<ProofVerif>]) -> Result<Vec<u8>, bincode::Error> {
        bincode::serialize(vec)
    }

    pub async fn exist(&self, root_path: &Path, tx_hash: Hash) -> bool {
        let file_path = root_path.join(self.get_relatif_path(tx_hash));
        tokio::fs::try_exists(file_path).await.unwrap_or(false)
    }
}

impl From<DbFile> for File<ProofVerif> {
    fn from(file: DbFile) -> Self {
        File::<ProofVerif>::new(file.name, file.url, file.checksum)
    }
}

// Describe a file generated by the VM.
#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct Vm(Hash);
impl File<Vm> {
    pub fn new(path: String, checksum: Hash, task_tx: Hash) -> Self {
        File::build(path, String::new(), checksum, Vm(task_tx))
    }

    pub fn get_relatif_path(&self) -> PathBuf {
        let mut file_path = Path::new(&self.name);
        if file_path.is_absolute() {
            file_path = file_path.strip_prefix("/").unwrap(); // Unwrap tested in `is_absolute()`.
        }

        let mut path = PathBuf::from(self.extention.0.to_string());
        path.push(file_path);
        path
    }

    pub async fn remove_file(&self, base_path: &Path) -> std::io::Result<()> {
        let src_file_path = base_path.join(self.get_relatif_path());
        tokio::fs::remove_file(src_file_path).await
    }
}

pub async fn move_vmfile(
    source: &File<Vm>,
    dest: &File<ProofVerif>,
    base_path: &Path,
    proofverif_tx_hash: Hash,
) -> Result<()> {
    // If the dest file already exist don't copy it.
    // Remove it from the VM.
    if dest.exist(base_path, proofverif_tx_hash).await {
        tracing::debug!(
            "move_vmfile: dest file already exist:{:#?}. Remove VM file:{:#?}",
            dest.get_relatif_path(proofverif_tx_hash),
            source.get_relatif_path()
        );
        source.remove_file(base_path).await.map_err(|e| e.into())
    } else {
        let src_file_path = base_path.to_path_buf().join(source.get_relatif_path());
        let dst_file_path = base_path
            .to_path_buf()
            .join(dest.get_relatif_path(proofverif_tx_hash));

        tracing::debug!(
            "move_vmfile: moving file from {:#?} to {:#?}",
            src_file_path,
            dst_file_path
        );

        // Ensure any necessary subdirectories exists.
        if let Some(parent) = dst_file_path.parent() {
            tokio::fs::create_dir_all(parent)
                .await
                .expect("task file mkdir");
        }

        tokio::fs::rename(src_file_path, dst_file_path)
            .await
            .map_err(|e| e.into())
    }
}

#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq)]
pub struct Image(Hash);
impl File<Image> {
    pub fn try_from_prg_meta_data(value: &transaction::ProgramMetadata) -> Self {
        File::build(
            value.name.clone(),
            value.image_file_url.clone(),
            value.image_file_checksum.clone().into(),
            Image(value.hash),
        )
    }
}

impl From<File<Image>> for File<Download> {
    fn from(file: File<Image>) -> Self {
        //image file has the image directory happened at the beginning.
        let mut extention = PathBuf::from("images");
        extention.push(file.extention.0.to_string());
        File::build(
            file.name,
            file.url,
            file.checksum,
            Download((extention.to_str().unwrap().to_string(), false)),
        )
    }
}
